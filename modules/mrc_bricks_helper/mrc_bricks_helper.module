<?php

/**
 * @file
 * mrc_bricks_helper.module
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Render\Element;
use Drupal\bricks_inline\Plugin\Field\FieldWidget\BricksTreeInlineWidget;
//testing line below
use Drupal\Component\Utility\NestedArray;

/**
 * Implements hook_field_widget_form_alter().
 */
function mrc_bricks_helper_field_widget_form_alter(&$element, FormStateInterface $form_state, $context) {
  if ($context['widget'] instanceof BricksTreeInlineWidget) {

    $view_mode_display = \Drupal::entityTypeManager()
      ->getStorage('entity_view_display');


    foreach (Element::children($element['entities']) as $delta) {

      $child = &$element['entities'][$delta];

      $eif_id = $element['#ief_id'];

      // TODO: MRCD8-204 - trying to open brick programmatically.
      $storage = $form_state->getStorage();
      $storage['inline_entity_form'][$eif_id]['entities'][$delta]['form'] = 'edit';
      $form_state->setStorage($storage);



      // If the entity doesn't have the view display, remove it as an option.
      foreach (array_keys($child['options']['view_mode']['#options']) as $view_mode_id) {

        $view_id = $child['#entity']->getEntityTypeId() . '.' . $child['#entity']->bundle() . '.' . $view_mode_id;

        if (empty($view_mode_display->load($view_id))) {
          unset($child['options']['view_mode']['#options'][$view_mode_id]);
        }
      }

      // Hide the view mode selection if only one option exists.
      if (count($child['options']['view_mode']['#options']) == 1) {
        $child['options']['view_mode']['#type'] = 'hidden';
        $child['options']['view_mode']['#value'] = key($child['options']['view_mode']['#options']);
      }
    }
  }
}

/**
 * Implements hook_preprocess_inline_entity_form_entity_table().
 *
 * When there is only one brick in a bricks field, the widget doesn't display
 * view mode or the classes. This function adds those to the table.
 *
 * @see bricks_inline_preprocess_inline_entity_form_entity_table().
 */
function mrc_bricks_helper_preprocess_inline_entity_form_entity_table(&$variables) {
  $element = $variables['form'];
  //kint($element);

  if (isset($element['#widget']) && $element['#widget'] == 'bricks_tree_inline') {
    // For now disable the nesting ability.
    if (!empty($variables['table']['#tabledrag'])) {
      $variables['table']['#tabledrag'] = [$variables['table']['#tabledrag'][0]];
    }

    $children = Element::children($element);
    // If there are more than 1 child, we rely on
    // bricks_inline_preprocess_inline_entity_form_entity_table() function.
    if (count($children) != 1) {
      return;
    }

    foreach ($children as $row => $key) {
      if ($key !== 'add_more') {
        $element[$key]['options']['#prefix'] = $variables['table']['#rows'][$row]['data'][0]['data'];
        $variables['table']['#rows'][$row]['data'][0]['data'] = \Drupal::service('renderer')
          ->render($element[$key]['options']);
      }
    }
  }
}

/**
 * Perform alterations before an entity form is included in the IEF widget.
 *
 * @param $entity_form
 *   Nested array of form elements that comprise the entity form.
 * @param $form_state
 *   The form state of the parent form.
 */
function mrc_bricks_helper_inline_entity_form_entity_form_alter(&$entity_form, &$form_state) {
  //This gets fired when you edit the brick, not in the node edit form.
  //dpm('firing');
  //kint($entity_form);
  //kint($form_state);
  //dpm($storage['inline_entity_form'][$eif_id]['entities'][$delta]['form']);
  //$storage = $form_state->getStorage();
  //$storage['inline_entity_form'][$eif_id]['entities'][$delta]['form'] = 'edit';
}

/**
 * Perform alterations before the reference form is included in the IEF widget.
 *
 * The reference form is used to add existing entities through an autocomplete
 * field
 *
 * @param $reference_form
 *   Nested array of form elements that comprise the reference form.
 * @param $form_state
 *   The form state of the parent form.
 */
function mrc_bricks_helper_inline_entity_form_reference_form_alter(&$reference_form, &$form_state) {
  //$reference_form['entity_id']['#description'] = t('New autocomplete description');
  //dpm('firing');
  //kint($reference_form);
  //kint($form_state);
  //dpm($storage['inline_entity_form'][$eif_id]['entities'][$delta]['form']);
  //$storage = $form_state->getStorage();
  //$storage['inline_entity_form'][$eif_id]['entities'][$delta]['form'] = 'edit';
}